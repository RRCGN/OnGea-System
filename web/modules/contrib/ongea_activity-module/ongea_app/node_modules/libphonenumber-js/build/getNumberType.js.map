{"version":3,"sources":["../source/getNumberType.js"],"names":["get_number_type","is_of_type","sort_out_arguments","check_number_length_for_type","merge_arrays","non_fixed_line_types","arg_1","arg_2","arg_3","input","metadata","country","hasCountry","Error","national_number","phone","nationalNumberPattern","type","pattern","_type","possibleLengths","indexOf","length","undefined","is_object","TypeError","type_info","possible_lengths","test_number_length_for_type","mobile_type","actual_length","minimum_length","_","a","b","merged","slice","element","push","sort"],"mappings":"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","file":"getNumberType.js","sourcesContent":["import parse, { is_viable_phone_number } from './parse'\r\n\r\nimport { matches_entirely } from './common'\r\n\r\nimport Metadata from './metadata'\r\n\r\nconst non_fixed_line_types =\r\n[\r\n\t'MOBILE',\r\n\t'PREMIUM_RATE',\r\n\t'TOLL_FREE',\r\n\t'SHARED_COST',\r\n\t'VOIP',\r\n\t'PERSONAL_NUMBER',\r\n\t'PAGER',\r\n\t'UAN',\r\n\t'VOICEMAIL'\r\n]\r\n\r\n// Finds out national phone number type (fixed line, mobile, etc)\r\nexport default function get_number_type(arg_1, arg_2, arg_3)\r\n{\r\n\tconst { input, metadata } = sort_out_arguments(arg_1, arg_2, arg_3)\r\n\r\n\t// When no input was passed\r\n\tif (!input)\r\n\t{\r\n\t\treturn\r\n\t}\r\n\r\n\t// When `parse()` returned `{}`\r\n\t// meaning that the phone number is not a valid one.\r\n\tif (!input.country)\r\n\t{\r\n\t\treturn\r\n\t}\r\n\r\n\tif (!metadata.hasCountry(input.country))\r\n\t{\r\n\t\tthrow new Error(`Unknown country: ${input.country}`)\r\n\t}\r\n\r\n\tconst national_number = input.phone\r\n\tmetadata.country(input.country)\r\n\r\n\t// The following is copy-pasted from the original function:\r\n\t// https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835\r\n\r\n\t// Is this national number even valid for this country\r\n\tif (!matches_entirely(national_number, metadata.nationalNumberPattern()))\r\n\t{\r\n\t\treturn\r\n\t}\r\n\r\n\t// Is it fixed line number\r\n\tif (is_of_type(national_number, 'FIXED_LINE', metadata))\r\n\t{\r\n\t\t// Because duplicate regular expressions are removed\r\n\t\t// to reduce metadata size, if \"mobile\" pattern is \"\"\r\n\t\t// then it means it was removed due to being a duplicate of the fixed-line pattern.\r\n\t\t//\r\n\t\tif (metadata.type('MOBILE') && metadata.type('MOBILE').pattern() === '')\r\n\t\t{\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\t// v1 metadata.\r\n\t\t// Legacy.\r\n\t\t// Deprecated.\r\n\t\tif (!metadata.type('MOBILE'))\r\n\t\t{\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\t// Check if the number happens to qualify as both fixed line and mobile.\r\n\t\t// (no such country in the minimal metadata set)\r\n\t\t/* istanbul ignore if */\r\n\t\tif (is_of_type(national_number, 'MOBILE', metadata))\r\n\t\t{\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\treturn 'FIXED_LINE'\r\n\t}\r\n\r\n\tfor (const _type of non_fixed_line_types)\r\n\t{\r\n\t\tif (is_of_type(national_number, _type, metadata))\r\n\t\t{\r\n\t\t\treturn _type\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function is_of_type(national_number, type, metadata)\r\n{\r\n\ttype = metadata.type(type)\r\n\r\n\tif (!type || !type.pattern())\r\n\t{\r\n\t\treturn false\r\n\t}\r\n\r\n\t// Check if any possible number lengths are present;\r\n\t// if so, we use them to avoid checking\r\n\t// the validation pattern if they don't match.\r\n\t// If they are absent, this means they match\r\n\t// the general description, which we have\r\n\t// already checked before a specific number type.\r\n\tif (type.possibleLengths() &&\r\n\t\ttype.possibleLengths().indexOf(national_number.length) < 0)\r\n\t{\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn matches_entirely(national_number, type.pattern())\r\n}\r\n\r\n// Sort out arguments\r\nexport function sort_out_arguments(arg_1, arg_2, arg_3)\r\n{\r\n\tlet input\r\n\tlet metadata\r\n\r\n\t// If the phone number is passed as a string.\r\n\t// `getNumberType('88005553535', ...)`.\r\n\tif (typeof arg_1 === 'string')\r\n\t{\r\n\t\t// If \"resrict country\" argument is being passed\r\n\t\t// then convert it to an `options` object.\r\n\t\t// `getNumberType('88005553535', 'RU', metadata)`.\r\n\t\tif (typeof arg_2 === 'string' || arg_2 === undefined)\r\n\t\t{\r\n\t\t\tmetadata = arg_3\r\n\r\n\t\t\t// `parse` extracts phone numbers from raw text,\r\n\t\t\t// therefore it will cut off all \"garbage\" characters,\r\n\t\t\t// while this `validate` function needs to verify\r\n\t\t\t// that the phone number contains no \"garbage\"\r\n\t\t\t// therefore the explicit `is_viable_phone_number` check.\r\n\t\t\tif (is_viable_phone_number(arg_1))\r\n\t\t\t{\r\n\t\t\t\tinput = parse(arg_1, arg_2, metadata)\r\n\t\t\t}\r\n\t\t}\r\n\t\t// No \"resrict country\" argument is being passed.\r\n\t\t// International phone number is passed.\r\n\t\t// `getNumberType('+78005553535', metadata)`.\r\n\t\telse\r\n\t\t{\r\n\t\t\tmetadata = arg_2\r\n\r\n\t\t\t// `parse` extracts phone numbers from raw text,\r\n\t\t\t// therefore it will cut off all \"garbage\" characters,\r\n\t\t\t// while this `validate` function needs to verify\r\n\t\t\t// that the phone number contains no \"garbage\"\r\n\t\t\t// therefore the explicit `is_viable_phone_number` check.\r\n\t\t\tif (is_viable_phone_number(arg_1))\r\n\t\t\t{\r\n\t\t\t\tinput = parse(arg_1, metadata)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// If the phone number is passed as a parsed phone number.\r\n\t// `getNumberType({ phone: '88005553535', country: 'RU' }, ...)`.\r\n\telse if (is_object(arg_1) && typeof arg_1.phone === 'string')\r\n\t{\r\n\t\t// The `arg_1` must be a valid phone number\r\n\t\t// as a whole, not just a part of it which gets parsed here.\r\n\t\tif (is_viable_phone_number(arg_1.phone))\r\n\t\t{\r\n\t\t\tinput = arg_1\r\n\t\t}\r\n\r\n\t\tmetadata = arg_2\r\n\t}\r\n\telse throw new TypeError('A phone number must either be a string or an object of shape { phone, [country] }.')\r\n\r\n\treturn { input, metadata: new Metadata(metadata) }\r\n}\r\n\r\n// Should only be called for the \"new\" metadata which has \"possible lengths\".\r\nexport function check_number_length_for_type(national_number, type, metadata)\r\n{\r\n\tconst type_info = metadata.type(type)\r\n\r\n\t// There should always be \"<possiblePengths/>\" set for every type element.\r\n\t// This is declared in the XML schema.\r\n\t// For size efficiency, where a sub-description (e.g. fixed-line)\r\n\t// has the same \"<possiblePengths/>\" as the \"general description\", this is missing,\r\n\t// so we fall back to the \"general description\". Where no numbers of the type\r\n\t// exist at all, there is one possible length (-1) which is guaranteed\r\n\t// not to match the length of any real phone number.\r\n\tlet possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths()\r\n\t// let local_lengths    = type_info && type.possibleLengthsLocal() || metadata.possibleLengthsLocal()\r\n\r\n\tif (type === 'FIXED_LINE_OR_MOBILE')\r\n\t{\r\n\t\t// No such country in metadata.\r\n\t\t/* istanbul ignore next */\r\n\t\tif (!metadata.type('FIXED_LINE'))\r\n\t\t{\r\n\t\t\t// The rare case has been encountered where no fixedLine data is available\r\n\t\t\t// (true for some non-geographical entities), so we just check mobile.\r\n\t\t\treturn test_number_length_for_type(national_number, 'MOBILE', metadata)\r\n\t\t}\r\n\r\n\t\tconst mobile_type = metadata.type('MOBILE')\r\n\r\n\t\tif (mobile_type)\r\n\t\t{\r\n\t\t\t// Merge the mobile data in if there was any. \"Concat\" creates a new\r\n\t\t\t// array, it doesn't edit possible_lengths in place, so we don't need a copy.\r\n\t\t\t// Note that when adding the possible lengths from mobile, we have\r\n\t\t\t// to again check they aren't empty since if they are this indicates\r\n\t\t\t// they are the same as the general desc and should be obtained from there.\r\n\t\t\tpossible_lengths = merge_arrays(possible_lengths, mobile_type.possibleLengths())\r\n\t\t\t// The current list is sorted; we need to merge in the new list and\r\n\t\t\t// re-sort (duplicates are okay). Sorting isn't so expensive because\r\n\t\t\t// the lists are very small.\r\n\r\n\t\t\t// if (local_lengths)\r\n\t\t\t// {\r\n\t\t\t// \tlocal_lengths = merge_arrays(local_lengths, mobile_type.possibleLengthsLocal())\r\n\t\t\t// }\r\n\t\t\t// else\r\n\t\t\t// {\r\n\t\t\t// \tlocal_lengths = mobile_type.possibleLengthsLocal()\r\n\t\t\t// }\r\n\t\t}\r\n\t}\r\n\t// If the type doesn't exist then return 'INVALID_LENGTH'.\r\n\telse if (type && !type_info)\r\n\t{\r\n\t\treturn 'INVALID_LENGTH'\r\n\t}\r\n\r\n\tconst actual_length = national_number.length\r\n\r\n\t// // This is safe because there is never an overlap beween the possible lengths\r\n\t// // and the local-only lengths; this is checked at build time.\r\n\t// if (local_lengths && local_lengths.indexOf(national_number.length) >= 0)\r\n\t// {\r\n\t// \treturn 'IS_POSSIBLE_LOCAL_ONLY'\r\n\t// }\r\n\r\n\tconst minimum_length = possible_lengths[0]\r\n\r\n\tif (minimum_length === actual_length)\r\n\t{\r\n\t\treturn 'IS_POSSIBLE'\r\n\t}\r\n\r\n\tif (minimum_length > actual_length)\r\n\t{\r\n\t\treturn 'TOO_SHORT'\r\n\t}\r\n\r\n\tif (possible_lengths[possible_lengths.length - 1] < actual_length)\r\n\t{\r\n\t\treturn 'TOO_LONG'\r\n\t}\r\n\r\n\t// We skip the first element since we've already checked it.\r\n\treturn possible_lengths.indexOf(actual_length, 1) >= 0 ? 'IS_POSSIBLE' : 'INVALID_LENGTH'\r\n}\r\n\r\n// Babel transforms `typeof` into some \"branches\"\r\n// so istanbul will show this as \"branch not covered\".\r\n/* istanbul ignore next */\r\nconst is_object = _ => typeof _ === 'object'\r\n\r\nexport function merge_arrays(a, b)\r\n{\r\n\tconst merged = a.slice()\r\n\r\n\tfor (const element of b)\r\n\t{\r\n\t\tif (a.indexOf(element) < 0)\r\n\t\t{\r\n\t\t\tmerged.push(element)\r\n\t\t}\r\n\t}\r\n\r\n\treturn merged.sort((a, b) => a - b)\r\n\r\n\t// ES6 version, requires Set polyfill.\r\n\t// let merged = new Set(a)\r\n\t// for (const element of b)\r\n\t// {\r\n\t// \tmerged.add(i)\r\n\t// }\r\n\t// return Array.from(merged).sort((a, b) => a - b)\r\n}"]}