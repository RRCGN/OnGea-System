{"version":3,"sources":["../source/findNumbers.common.js"],"names":["PLUS_CHARS","isLatinLetter","isInvalidPunctuationSymbol","OPENING_PARENS","CLOSING_PARENS","LEAD_CLASS","LEAD_CLASS_LEADING","RegExp","MATCHING_BRACKETS_ENTIRE","openingParens","nonParens","closingParens","bracketPairLimit","PUB_PAGES","Leniency","POSSIBLE","number","candidate","metadata","parseNumber","extended","possible","VALID","isValidNumber","containsOnlyValidXChars","toString","isNationalPrefixPresentIfRequired","STRICT_GROUPING","candidateString","containsMoreThanOneSlashInNationalNumber","checkNumberGroupingIsValid","allNumberGroupsRemainGrouped","EXACT_GROUPING","allNumberGroupsAreExactlyPresent","isValidCandidate","offset","text","leniency","test","previousChar","lastCharIndex","length","nextChar"],"mappings":"AAAA;;AAEA,SAECA,UAFD,QAIK,UAJL;;AAMA,SAECC,aAFD,EAGCC,0BAHD,QAKK,gBALL;;AAOA,OAAO,IAAMC,iBAAiB,kBAAvB;AACP,OAAO,IAAMC,iBAAiB,kBAAvB;;AAEP,OAAO,IAAMC,mBAAiBF,cAAjB,GAAkCH,UAAlC,MAAN;;AAEP;AACA,IAAMM,qBAAqB,IAAIC,MAAJ,CAAW,MAAMF,UAAjB,CAA3B;;AAEA;;;;;;;;;AASA,IAAMG,2BAA2B,IAAID,MAAJ,CAEhC,MAEE,MAFF,GAEWE,aAFX,GAE2B,KAF3B,GAEmC,KAFnC,GAE2CC,SAF3C,GAEuD,GAFvD,GAE6D,GAF7D,GAEmEC,aAFnE,GAEmF,KAFnF,GAGED,SAHF,GAGc,GAHd,GAIE,MAJF,GAIWD,aAJX,GAI2B,GAJ3B,GAIiCC,SAJjC,GAI6C,IAJ7C,GAIoDC,aAJpD,GAIoE,IAJpE,GAI2EC,gBAJ3E,GAKEF,SALF,GAKc,GALd,GAOE,GAT8B,CAAjC;;AAYA;;;;;;;AAOA,IAAMG,YAAY,kCAAlB;;AAEA;;;;AAIA,OAAO,IAAMC,WACb;AACC;;;AAGAC,SAJD,oBAIUC,MAJV,EAIkBC,SAJlB,EAI6BC,QAJ7B,EAKC;AACC,SAAOC,YAAYH,MAAZ,EAAoB,EAAEI,UAAU,IAAZ,EAApB,EAAwCF,QAAxC,EAAkDG,QAAzD;AACA,EAPF;;;AASC;;;;;AAKAC,MAdD,iBAcON,MAdP,EAceC,SAdf,EAc0BC,QAd1B,EAeC;AACC,MAAI,CAACK,cAAcP,MAAd,EAAsBE,QAAtB,CAAD,IACH,CAACM,wBAAwBR,MAAxB,EAAgCC,UAAUQ,QAAV,EAAhC,EAAsDP,QAAtD,CADF,EAEA;AACC,UAAO,KAAP;AACA;;AAED,SAAOQ,kCAAkCV,MAAlC,EAA0CE,QAA1C,CAAP;AACC,EAvBH;;;AAyBC;;;;;;;;;;;;AAYAS,gBArCD,2BAqCiBX,MArCjB,EAqCyBC,SArCzB,EAqCoCC,QArCpC,EAsCC;AACC,MAAMU,kBAAkBX,UAAUQ,QAAV,EAAxB;;AAEA,MAAI,CAACF,cAAcP,MAAd,EAAsBE,QAAtB,CAAD,IACA,CAACM,wBAAwBR,MAAxB,EAAgCY,eAAhC,EAAiDV,QAAjD,CADD,IAEAW,yCAAyCb,MAAzC,EAAiDY,eAAjD,CAFA,IAGA,CAACF,kCAAkCV,MAAlC,EAA0CE,QAA1C,CAHL,EAIA;AACC,UAAO,KAAP;AACA;;AAED,SAAOY,2BAENd,MAFM,EAGNC,SAHM,EAINC,QAJM,EAKNa,4BALM,CAAP;AAOC,EAxDH;;;AA0DC;;;;;;;;;;;AAWAC,eArED,0BAqEgBhB,MArEhB,EAqEwBC,SArExB,EAqEmCC,QArEnC,EAsEC;AACC,MAAMU,kBAAkBX,UAAUQ,QAAV,EAAxB;;AAEA,MAAI,CAACF,cAAcP,MAAd,EAAsBE,QAAtB,CAAD,IACA,CAACM,wBAAwBR,MAAxB,EAAgCY,eAAhC,EAAiDV,QAAjD,CADD,IAEAW,yCAAyCb,MAAzC,EAAiDY,eAAjD,CAFA,IAGA,CAACF,kCAAkCV,MAAlC,EAA0CE,QAA1C,CAHL,EAIA;AACC,UAAO,KAAP;AACA;;AAED,SAAOY,2BAENd,MAFM,EAGNC,SAHM,EAINC,QAJM,EAKJe,gCALI,CAAP;AAOA;AAxFF,CADO;;AA4FP,OAAO,SAASC,gBAAT,CAA0BjB,SAA1B,EAAqCkB,MAArC,EAA6CC,IAA7C,EAAmDC,QAAnD,EACP;AACC;AACA;AACA,KAAI,CAAC7B,yBAAyB8B,IAAzB,CAA8BrB,SAA9B,CAAD,IAA6CJ,UAAUyB,IAAV,CAAerB,SAAf,CAAjD,EAA4E;AAC3E;AACA;;AAED;AACA;AACA,KAAIoB,aAAavB,SAASC,QAA1B,EACA;AACC;AACA;AACA;AACA,MAAIoB,SAAS,CAAT,IAAc,CAAC7B,mBAAmBgC,IAAnB,CAAwBrB,SAAxB,CAAnB,EACA;AACC,OAAMsB,eAAeH,KAAKD,SAAS,CAAd,CAArB;AACA;AACA,OAAIjC,2BAA2BqC,YAA3B,KAA4CtC,cAAcsC,YAAd,CAAhD,EAA6E;AAC5E,WAAO,KAAP;AACA;AACD;;AAED,MAAMC,gBAAgBL,SAASlB,UAAUwB,MAAzC;AACA,MAAID,gBAAgBJ,KAAKK,MAAzB,EACA;AACC,OAAMC,WAAWN,KAAKI,aAAL,CAAjB;AACA,OAAItC,2BAA2BwC,QAA3B,KAAwCzC,cAAcyC,QAAd,CAA5C,EAAqE;AACpE,WAAO,KAAP;AACA;AACD;AACD;;AAED,QAAO,IAAP;AACA","file":"findNumbers.common.js","sourcesContent":["// Copy-pasted from `PhoneNumberMatcher.js`.\r\n\r\nimport\r\n{\r\n\tPLUS_CHARS\r\n}\r\nfrom './common'\r\n\r\nimport\r\n{\r\n\tisLatinLetter,\r\n\tisInvalidPunctuationSymbol\r\n}\r\nfrom './utf-8.common'\r\n\r\nexport const OPENING_PARENS = '(\\\\[\\uFF08\\uFF3B'\r\nexport const CLOSING_PARENS = ')\\\\]\\uFF09\\uFF3D'\r\n\r\nexport const LEAD_CLASS = `[${OPENING_PARENS}${PLUS_CHARS}]`\r\n\r\n// Punctuation that may be at the start of a phone number - brackets and plus signs.\r\nconst LEAD_CLASS_LEADING = new RegExp('^' + LEAD_CLASS)\r\n\r\n/**\r\n * Pattern to check that brackets match. Opening brackets should be closed within a phone number.\r\n * This also checks that there is something inside the brackets. Having no brackets at all is also\r\n * fine.\r\n *\r\n * An opening bracket at the beginning may not be closed, but subsequent ones should be.  It's\r\n * also possible that the leading bracket was dropped, so we shouldn't be surprised if we see a\r\n * closing bracket first. We limit the sets of brackets in a phone number to four.\r\n */\r\nconst MATCHING_BRACKETS_ENTIRE = new RegExp\r\n(\r\n\t'^'\r\n\r\n\t+ \"(?:[\" + openingParens + \"])?\" + \"(?:\" + nonParens + \"+\" + \"[\" + closingParens + \"])?\"\r\n\t+ nonParens + \"+\"\r\n\t+ \"(?:[\" + openingParens + \"]\" + nonParens + \"+[\" + closingParens + \"])\" + bracketPairLimit\r\n\t+ nonParens + \"*\"\r\n\r\n\t+ '$'\r\n)\r\n\r\n/**\r\n * Matches strings that look like publication pages. Example:\r\n * <pre>Computing Complete Answers to Queries in the Presence of Limited Access Patterns.\r\n * Chen Li. VLDB J. 12(3): 211-227 (2003).</pre>\r\n *\r\n * The string \"211-227 (2003)\" is not a telephone number.\r\n */\r\nconst PUB_PAGES = /\\d{1,5}-+\\d{1,5}\\s{0,4}\\(\\d{1,4}/\r\n\r\n/**\r\n * Leniency when finding potential phone numbers in text segments\r\n * The levels here are ordered in increasing strictness.\r\n */\r\nexport const Leniency =\r\n{\r\n\t/**\r\n\t * Phone numbers accepted are \"possible\", but not necessarily \"valid\".\r\n\t */\r\n\tPOSSIBLE(number, candidate, metadata)\r\n\t{\r\n\t\treturn parseNumber(number, { extended: true }, metadata).possible\r\n\t},\r\n\r\n\t/**\r\n\t * Phone numbers accepted are \"possible\" and \"valid\".\r\n\t * Numbers written in national format must have their national-prefix\r\n\t * present if it is usually written for a number of this type.\r\n\t */\r\n\tVALID(number, candidate, metadata)\r\n\t{\r\n\t\tif (!isValidNumber(number, metadata) ||\r\n\t\t\t!containsOnlyValidXChars(number, candidate.toString(), metadata))\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\treturn isNationalPrefixPresentIfRequired(number, metadata)\r\n  },\r\n\r\n\t/**\r\n\t * Phone numbers accepted are \"valid\" and\r\n\t * are grouped in a possible way for this locale. For example, a US number written as\r\n\t * \"65 02 53 00 00\" and \"650253 0000\" are not accepted at this leniency level, whereas\r\n\t * \"650 253 0000\", \"650 2530000\" or \"6502530000\" are.\r\n\t * Numbers with more than one '/' symbol in the national significant number\r\n\t * are also dropped at this level.\r\n\t *\r\n\t * Warning: This level might result in lower coverage especially for regions outside of\r\n\t * country code \"+1\". If you are not sure about which level to use,\r\n\t * email the discussion group libphonenumber-discuss@googlegroups.com.\r\n\t */\r\n\tSTRICT_GROUPING(number, candidate, metadata)\r\n\t{\r\n\t\tconst candidateString = candidate.toString()\r\n\r\n\t\tif (!isValidNumber(number, metadata)\r\n\t\t\t|| !containsOnlyValidXChars(number, candidateString, metadata)\r\n\t\t\t|| containsMoreThanOneSlashInNationalNumber(number, candidateString)\r\n\t\t\t|| !isNationalPrefixPresentIfRequired(number, metadata))\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\treturn checkNumberGroupingIsValid\r\n\t\t(\r\n\t\t\tnumber,\r\n\t\t\tcandidate,\r\n\t\t\tmetadata,\r\n\t\t\tallNumberGroupsRemainGrouped\r\n\t\t)\r\n  },\r\n\r\n\t/**\r\n\t * Phone numbers accepted are {@linkplain PhoneNumberUtil#isValidNumber(PhoneNumber) valid} and\r\n\t * are grouped in the same way that we would have formatted it, or as a single block. For\r\n\t * example, a US number written as \"650 2530000\" is not accepted at this leniency level, whereas\r\n\t * \"650 253 0000\" or \"6502530000\" are.\r\n\t * Numbers with more than one '/' symbol are also dropped at this level.\r\n\t * <p>\r\n\t * Warning: This level might result in lower coverage especially for regions outside of country\r\n\t * code \"+1\". If you are not sure about which level to use, email the discussion group\r\n\t * libphonenumber-discuss@googlegroups.com.\r\n\t */\r\n\tEXACT_GROUPING(number, candidate, metadata)\r\n\t{\r\n\t\tconst candidateString = candidate.toString()\r\n\r\n\t\tif (!isValidNumber(number, metadata)\r\n\t\t\t|| !containsOnlyValidXChars(number, candidateString, metadata)\r\n\t\t\t|| containsMoreThanOneSlashInNationalNumber(number, candidateString)\r\n\t\t\t|| !isNationalPrefixPresentIfRequired(number, metadata))\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\treturn checkNumberGroupingIsValid\r\n\t\t(\r\n\t\t\tnumber,\r\n\t\t\tcandidate,\r\n\t\t\tmetadata,\r\n   \t\tallNumberGroupsAreExactlyPresent\r\n\t\t)\r\n\t}\r\n}\r\n\r\nexport function isValidCandidate(candidate, offset, text, leniency)\r\n{\r\n\t// Check the candidate doesn't contain any formatting\r\n\t// which would indicate that it really isn't a phone number.\r\n\tif (!MATCHING_BRACKETS_ENTIRE.test(candidate) || PUB_PAGES.test(candidate)) {\r\n\t\treturn\r\n\t}\r\n\r\n\t// If leniency is set to VALID or stricter, we also want to skip numbers that are surrounded\r\n\t// by Latin alphabetic characters, to skip cases like abc8005001234 or 8005001234def.\r\n\tif (leniency !== Leniency.POSSIBLE)\r\n\t{\r\n\t\t// If the candidate is not at the start of the text,\r\n\t\t// and does not start with phone-number punctuation,\r\n\t\t// check the previous character.\r\n\t\tif (offset > 0 && !LEAD_CLASS_LEADING.test(candidate))\r\n\t\t{\r\n\t\t\tconst previousChar = text[offset - 1]\r\n\t\t\t// We return null if it is a latin letter or an invalid punctuation symbol.\r\n\t\t\tif (isInvalidPunctuationSymbol(previousChar) || isLatinLetter(previousChar)) {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst lastCharIndex = offset + candidate.length\r\n\t\tif (lastCharIndex < text.length)\r\n\t\t{\r\n\t\t\tconst nextChar = text[lastCharIndex]\r\n\t\t\tif (isInvalidPunctuationSymbol(nextChar) || isLatinLetter(nextChar)) {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn true\r\n}"]}