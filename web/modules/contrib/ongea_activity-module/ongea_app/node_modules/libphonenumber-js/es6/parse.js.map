{"version":3,"sources":["../source/parse.js"],"names":["extractCountryCallingCode","VALID_DIGITS","VALID_PUNCTUATION","PLUS_CHARS","MAX_LENGTH_FOR_NSN","matches_entirely","create_extension_pattern","parseIncompletePhoneNumber","Metadata","getCountryCallingCode","get_number_type","check_number_length_for_type","parseRFC3966","MIN_LENGTH_FOR_NSN","MAX_INPUT_STRING_LENGTH","EXTN_PATTERNS_FOR_PARSING","EXTN_PATTERN","RegExp","MIN_LENGTH_PHONE_NUMBER_PATTERN","VALID_PHONE_NUMBER","VALID_PHONE_NUMBER_PATTERN","PHONE_NUMBER_START_PATTERN","AFTER_PHONE_NUMBER_END_PATTERN","default_options","country","parse","arg_1","arg_2","arg_3","arg_4","sort_out_arguments","text","options","metadata","defaultCountry","hasCountry","Error","parse_input","formatted_phone_number","number","ext","parse_phone_number","national_number","countryCallingCode","carrierCode","selectedCountry","length","valid","nationalNumberPattern","extended","result","possible","possibleLengths","is_possible_number","undefined","phone","is_viable_phone_number","test","extract_formatted_phone_number","starts_at","search","slice","replace","strip_national_prefix_and_carrier_code","nationalPrefixForParsing","national_prefix_pattern","national_prefix_matcher","exec","national_significant_number","captured_groups_count","nationalPrefixTransformRule","find_country_code","country_calling_code","national_phone_number","possible_countries","countryCallingCodes","_find_country_code","leadingDigits","TypeError","strip_extension","start","number_without_extension","matches","match","i","is_international","indexOf","with_extension_stripped","default_country","chooseCountryByCountryCallingCode","parse_national_number","carrier_code","exactCountry","potential_national_number"],"mappings":"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","file":"parse.js","sourcesContent":["// This is a port of Google Android `libphonenumber`'s\r\n// `phonenumberutil.js` of 17th November, 2016.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\r\n\r\nimport\r\n{\r\n\textractCountryCallingCode,\r\n\tVALID_DIGITS,\r\n\tVALID_PUNCTUATION,\r\n\tPLUS_CHARS,\r\n\tMAX_LENGTH_FOR_NSN,\r\n\tmatches_entirely,\r\n\tcreate_extension_pattern\r\n}\r\nfrom './common'\r\n\r\nimport parseIncompletePhoneNumber from './parseIncompletePhoneNumber'\r\n\r\nimport Metadata from './metadata'\r\n\r\nimport getCountryCallingCode from './getCountryCallingCode'\r\n\r\nimport get_number_type, { check_number_length_for_type } from './getNumberType'\r\n\r\nimport { parseRFC3966 } from './RFC3966'\r\n\r\n// The minimum length of the national significant number.\r\nconst MIN_LENGTH_FOR_NSN = 2\r\n\r\n// We don't allow input strings for parsing to be longer than 250 chars.\r\n// This prevents malicious input from consuming CPU.\r\nconst MAX_INPUT_STRING_LENGTH = 250\r\n\r\n/**\r\n * Regexp of all possible ways to write extensions, for use when parsing. This\r\n * will be run as a case-insensitive regexp match. Wide character versions are\r\n * also provided after each ASCII version. There are three regular expressions\r\n * here. The first covers RFC 3966 format, where the extension is added using\r\n * ';ext='. The second more generic one starts with optional white space and\r\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\r\n * /commas and then the numbers themselves. The other one covers the special\r\n * case of American numbers where the extension is written with a hash at the\r\n * end, such as '- 503#'. Note that the only capturing groups should be around\r\n * the digits that you want to capture as part of the extension, or else parsing\r\n * will fail! We allow two options for representing the accented o - the\r\n * character itself, and one in the unicode decomposed form with the combining\r\n * acute accent.\r\n */\r\nconst EXTN_PATTERNS_FOR_PARSING = create_extension_pattern('parsing')\r\n\r\n// Regexp of all known extension prefixes used by different regions followed by\r\n// 1 or more valid digits, for use when parsing.\r\nconst EXTN_PATTERN = new RegExp('(?:' + EXTN_PATTERNS_FOR_PARSING + ')$', 'i')\r\n\r\n//  Regular expression of viable phone numbers. This is location independent.\r\n//  Checks we have at least three leading digits, and only valid punctuation,\r\n//  alpha characters and digits in the phone number. Does not include extension\r\n//  data. The symbol 'x' is allowed here as valid punctuation since it is often\r\n//  used as a placeholder for carrier codes, for example in Brazilian phone\r\n//  numbers. We also allow multiple '+' characters at the start.\r\n//\r\n//  Corresponds to the following:\r\n//  [digits]{minLengthNsn}|\r\n//  plus_sign*\r\n//  (([punctuation]|[star])*[digits]){3,}([punctuation]|[star]|[digits]|[alpha])*\r\n//\r\n//  The first reg-ex is to allow short numbers (two digits long) to be parsed if\r\n//  they are entered as \"15\" etc, but only if there is no punctuation in them.\r\n//  The second expression restricts the number of digits to three or more, but\r\n//  then allows them to be in international form, and to have alpha-characters\r\n//  and punctuation. We split up the two reg-exes here and combine them when\r\n//  creating the reg-ex VALID_PHONE_NUMBER_PATTERN itself so we can prefix it\r\n//  with ^ and append $ to each branch.\r\n//\r\n//  \"Note VALID_PUNCTUATION starts with a -,\r\n//   so must be the first in the range\" (c) Google devs.\r\n//  (wtf did they mean by saying that; probably nothing)\r\n//\r\nconst MIN_LENGTH_PHONE_NUMBER_PATTERN = '[' + VALID_DIGITS + ']{' + MIN_LENGTH_FOR_NSN + '}'\r\n//\r\n// And this is the second reg-exp:\r\n// (see MIN_LENGTH_PHONE_NUMBER_PATTERN for a full description of this reg-exp)\r\n//\r\nconst VALID_PHONE_NUMBER =\r\n\t'[' + PLUS_CHARS + ']{0,1}' +\r\n\t'(?:' +\r\n\t\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t\t'[' + VALID_DIGITS + ']' +\r\n\t'){3,}' +\r\n\t'[' +\r\n\t\tVALID_PUNCTUATION +\r\n\t\tVALID_DIGITS +\r\n\t']*'\r\n\r\n// The combined regular expression for valid phone numbers:\r\n//\r\nconst VALID_PHONE_NUMBER_PATTERN = new RegExp\r\n(\r\n\t// Either a short two-digit-only phone number\r\n\t'^' +\r\n\t\tMIN_LENGTH_PHONE_NUMBER_PATTERN +\r\n\t'$' +\r\n\t'|' +\r\n\t// Or a longer fully parsed phone number (min 3 characters)\r\n\t'^' +\r\n\t\tVALID_PHONE_NUMBER +\r\n\t\t// Phone number extensions\r\n\t\t'(?:' + EXTN_PATTERNS_FOR_PARSING + ')?' +\r\n\t'$'\r\n,\r\n'i')\r\n\r\n// This consists of the plus symbol, digits, and arabic-indic digits.\r\nconst PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']')\r\n\r\n// Regular expression of trailing characters that we want to remove.\r\nconst AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + ']+$')\r\n\r\nconst default_options =\r\n{\r\n\tcountry: {}\r\n}\r\n\r\n// `options`:\r\n//  {\r\n//    country:\r\n//    {\r\n//      restrict - (a two-letter country code)\r\n//                 the phone number must be in this country\r\n//\r\n//      default - (a two-letter country code)\r\n//                default country to use for phone number parsing and validation\r\n//                (if no country code could be derived from the phone number)\r\n//    }\r\n//  }\r\n//\r\n// Returns `{ country, number }`\r\n//\r\n// Example use cases:\r\n//\r\n// ```js\r\n// parse('8 (800) 555-35-35', 'RU')\r\n// parse('8 (800) 555-35-35', 'RU', metadata)\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\r\n// parse('+7 800 555 35 35')\r\n// parse('+7 800 555 35 35', metadata)\r\n// ```\r\n//\r\nexport default function parse(arg_1, arg_2, arg_3, arg_4)\r\n{\r\n\tconst { text, options, metadata } = sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\r\n\r\n\t// Validate `defaultCountry`.\r\n\tif (options.defaultCountry && !metadata.hasCountry(options.defaultCountry))\r\n\t{\r\n\t\tthrow new Error(`Unknown country: ${options.defaultCountry}`)\r\n\t}\r\n\r\n\t// Parse the phone number.\r\n\tconst { number: formatted_phone_number, ext } = parse_input(text)\r\n\r\n\t// If the phone number is not viable then return nothing.\r\n\tif (!formatted_phone_number)\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\tconst\r\n\t{\r\n\t\tcountry,\r\n\t\tnational_number,\r\n\t\tcountryCallingCode,\r\n\t\tcarrierCode\r\n\t}\r\n\t= parse_phone_number\r\n\t(\r\n\t\tformatted_phone_number,\r\n\t\toptions.defaultCountry,\r\n\t\tmetadata\r\n\t)\r\n\r\n\tif (!metadata.selectedCountry())\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\t//\r\n\t// A sidenote:\r\n\t//\r\n\t// They say that sometimes national (significant) numbers\r\n\t// can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\r\n\t// https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\r\n\t// Such numbers will just be discarded.\r\n\t//\r\n\tif (national_number.length < MIN_LENGTH_FOR_NSN ||\r\n\t\tnational_number.length > MAX_LENGTH_FOR_NSN)\r\n\t{\r\n\t\t// Google's demo just throws an error in this case.\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Check if national phone number pattern matches the number\r\n\t// National number pattern is different for each country,\r\n\t// even for those ones which are part of the \"NANPA\" group.\r\n\tconst valid = country && matches_entirely(national_number, metadata.nationalNumberPattern()) ? true : false\r\n\r\n\tif (!options.extended)\r\n\t{\r\n\t\treturn valid ? result(country, national_number, ext) : {}\r\n\t}\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tcarrierCode,\r\n\t\tvalid,\r\n\t\tpossible : valid ? true : (options.extended === true) && metadata.possibleLengths() && is_possible_number(national_number, countryCallingCode !== undefined, metadata),\r\n\t\tphone    : national_number,\r\n\t\text\r\n\t}\r\n}\r\n\r\n// Checks to see if the string of characters could possibly be a phone number at\r\n// all. At the moment, checks to see that the string begins with at least 2\r\n// digits, ignoring any punctuation commonly found in phone numbers. This method\r\n// does not require the number to be normalized in advance - but does assume\r\n// that leading non-number symbols have been removed, such as by the method\r\n// `extract_possible_number`.\r\n//\r\nexport function is_viable_phone_number(number)\r\n{\r\n\treturn number.length >= MIN_LENGTH_FOR_NSN &&\r\n\t\tVALID_PHONE_NUMBER_PATTERN.test(number)\r\n}\r\n\r\n/**\r\n * Extracts a parseable phone number.\r\n * @param  {string} text - Input.\r\n * @return {string}.\r\n */\r\nexport function extract_formatted_phone_number(text)\r\n{\r\n\tif (!text || text.length > MAX_INPUT_STRING_LENGTH)\r\n\t{\r\n\t\treturn\r\n\t}\r\n\r\n\t// Attempt to extract a possible number from the string passed in\r\n\r\n\tconst starts_at = text.search(PHONE_NUMBER_START_PATTERN)\r\n\r\n\tif (starts_at < 0)\r\n\t{\r\n\t\treturn\r\n\t}\r\n\r\n\treturn text\r\n\t\t// Trim everything to the left of the phone number\r\n\t\t.slice(starts_at)\r\n\t\t// Remove trailing non-numerical characters\r\n\t\t.replace(AFTER_PHONE_NUMBER_END_PATTERN, '')\r\n}\r\n\r\n// Strips any national prefix (such as 0, 1) present in the number provided.\r\n// \"Carrier codes\" are only used  in Colombia and Brazil,\r\n// and only when dialing within those countries from a mobile phone to a fixed line number.\r\nexport function strip_national_prefix_and_carrier_code(number, metadata)\r\n{\r\n\tif (!number || !metadata.nationalPrefixForParsing())\r\n\t{\r\n\t\treturn { number }\r\n\t}\r\n\r\n\t// Attempt to parse the first digits as a national prefix\r\n\tconst national_prefix_pattern = new RegExp('^(?:' + metadata.nationalPrefixForParsing() + ')')\r\n\tconst national_prefix_matcher = national_prefix_pattern.exec(number)\r\n\r\n\t// If no national prefix is present in the phone number,\r\n\t// but the national prefix is optional for this country,\r\n\t// then consider this phone number valid.\r\n\t//\r\n\t// Google's reference `libphonenumber` implementation\r\n\t// wouldn't recognize such phone numbers as valid,\r\n\t// but I think it would perfectly make sense\r\n\t// to consider such phone numbers as valid\r\n\t// because if a national phone number was originally\r\n\t// formatted without the national prefix\r\n\t// then it must be parseable back into the original national number.\r\n\t// In other words, `parse(format(number))`\r\n\t// must always be equal to `number`.\r\n\t//\r\n\tif (!national_prefix_matcher)\r\n\t{\r\n\t\treturn { number }\r\n\t}\r\n\r\n\tlet national_significant_number\r\n\r\n\t// `national_prefix_for_parsing` capturing groups\r\n\t// (used only for really messy cases: Argentina, Brazil, Mexico, Somalia)\r\n\tconst captured_groups_count = national_prefix_matcher.length - 1\r\n\r\n\t// If the national number tranformation is needed then do it.\r\n\t//\r\n\t// I don't know what did they mean by `&& national_prefix_matcher[captured_groups_count]`.\r\n\t// https://github.com/googlei18n/libphonenumber/blob/d978e59c2e6b1ddfb6816cd190e1b62d9a96bc3b/javascript/i18n/phonenumbers/phonenumberutil.js#L3885\r\n\t// https://github.com/googlei18n/libphonenumber/blob/d978e59c2e6b1ddfb6816cd190e1b62d9a96bc3b/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L2906\r\n\t//\r\n\tif (metadata.nationalPrefixTransformRule() && national_prefix_matcher[captured_groups_count])\r\n\t{\r\n\t\tnational_significant_number = number.replace(national_prefix_pattern, metadata.nationalPrefixTransformRule())\r\n\t}\r\n\t// Else, no transformation is necessary,\r\n\t// and just strip the national prefix.\r\n\telse\r\n\t{\r\n\t\tnational_significant_number = number.slice(national_prefix_matcher[0].length)\r\n\t}\r\n\r\n\tlet carrierCode\r\n\tif (captured_groups_count > 0)\r\n\t{\r\n\t\tcarrierCode = national_prefix_matcher[1]\r\n\t}\r\n\r\n\t// The following is done in `get_country_and_national_number_for_local_number()` instead.\r\n\t//\r\n\t// // Verify the parsed national (significant) number for this country\r\n\t// const national_number_rule = new RegExp(metadata.nationalNumberPattern())\r\n\t// //\r\n\t// // If the original number (before stripping national prefix) was viable,\r\n\t// // and the resultant number is not, then prefer the original phone number.\r\n\t// // This is because for some countries (e.g. Russia) the same digit could be both\r\n\t// // a national prefix and a leading digit of a valid national phone number,\r\n\t// // like `8` is the national prefix for Russia and both\r\n\t// // `8 800 555 35 35` and `800 555 35 35` are valid numbers.\r\n\t// if (matches_entirely(number, national_number_rule) &&\r\n\t// \t\t!matches_entirely(national_significant_number, national_number_rule))\r\n\t// {\r\n\t// \treturn number\r\n\t// }\r\n\r\n\t// Return the parsed national (significant) number\r\n   return {\r\n   \tnumber: national_significant_number,\r\n   \tcarrierCode\r\n   }\r\n}\r\n\r\nexport function find_country_code(country_calling_code, national_phone_number, metadata)\r\n{\r\n\t// Is always non-empty, because `country_calling_code` is always valid\r\n\tconst possible_countries = metadata.countryCallingCodes()[country_calling_code]\r\n\r\n\t// If there's just one country corresponding to the country code,\r\n\t// then just return it, without further phone number digits validation.\r\n\tif (possible_countries.length === 1)\r\n\t{\r\n\t\treturn possible_countries[0]\r\n\t}\r\n\r\n\treturn _find_country_code(possible_countries, national_phone_number, metadata.metadata)\r\n}\r\n\r\n// Changes `metadata` `country`.\r\nfunction _find_country_code(possible_countries, national_phone_number, metadata)\r\n{\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\tfor (const country of possible_countries)\r\n\t{\r\n\t\tmetadata.country(country)\r\n\r\n\t\t// Leading digits check would be the simplest one\r\n\t\tif (metadata.leadingDigits())\r\n\t\t{\r\n\t\t\tif (national_phone_number &&\r\n\t\t\t\tnational_phone_number.search(metadata.leadingDigits()) === 0)\r\n\t\t\t{\r\n\t\t\t\treturn country\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Else perform full validation with all of those\r\n\t\t// fixed-line/mobile/etc regular expressions.\r\n\t\telse if (get_number_type({ phone: national_phone_number, country }, metadata.metadata))\r\n\t\t{\r\n\t\t\treturn country\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Sort out arguments\r\nfunction sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\r\n{\r\n\tlet text\r\n\tlet options\r\n\tlet metadata\r\n\r\n\t// If the phone number is passed as a string.\r\n\t// `parse('88005553535', ...)`.\r\n\tif (typeof arg_1 === 'string')\r\n\t{\r\n\t\ttext = arg_1\r\n\t}\r\n\telse throw new TypeError('A phone number for parsing must be a string.')\r\n\r\n\t// If \"default country\" argument is being passed\r\n\t// then move it to `options`.\r\n\t// `parse('88005553535', 'RU', [options], metadata)`.\r\n\tif (typeof arg_2 === 'string')\r\n\t{\r\n\t\tif (arg_4)\r\n\t\t{\r\n\t\t\toptions = { defaultCountry: arg_2, ...arg_3 }\r\n\t\t\tmetadata = arg_4\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\toptions = { defaultCountry: arg_2 }\r\n\t\t\tmetadata = arg_3\r\n\t\t}\r\n\t}\r\n\t// No \"default country\" argument is being passed.\r\n\t// International phone number is passed.\r\n\t// `parse('+78005553535', [options], metadata)`.\r\n\telse\r\n\t{\r\n\t\tif (arg_3)\r\n\t\t{\r\n\t\t\toptions  = arg_2\r\n\t\t\tmetadata = arg_3\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmetadata = arg_2\r\n\t\t}\r\n\t}\r\n\r\n\t// Apply default options.\r\n\tif (options)\r\n\t{\r\n\t\toptions = { ...default_options, ...options }\r\n\t}\r\n\telse\r\n\t{\r\n\t\toptions = default_options\r\n\t}\r\n\r\n\treturn { text, options, metadata: new Metadata(metadata) }\r\n}\r\n\r\n// Strips any extension (as in, the part of the number dialled after the call is\r\n// connected, usually indicated with extn, ext, x or similar) from the end of\r\n// the number, and returns it.\r\nfunction strip_extension(number)\r\n{\r\n\tconst start = number.search(EXTN_PATTERN)\r\n\tif (start < 0)\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// If we find a potential extension, and the number preceding this is a viable\r\n\t// number, we assume it is an extension.\r\n\tconst number_without_extension = number.slice(0, start)\r\n\t/* istanbul ignore if - seems a bit of a redundant check */\r\n\tif (!is_viable_phone_number(number_without_extension))\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\tconst matches = number.match(EXTN_PATTERN)\r\n\tlet i = 1\r\n\twhile (i < matches.length)\r\n\t{\r\n\t\tif (matches[i] != null && matches[i].length > 0)\r\n\t\t{\r\n\t\t\treturn {\r\n\t\t\t\tnumber : number_without_extension,\r\n\t\t\t\text    : matches[i]\r\n\t\t\t}\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n}\r\n\r\nfunction is_possible_number(national_number, is_international, metadata)\r\n{\r\n\tswitch (check_number_length_for_type(national_number, undefined, metadata))\r\n\t{\r\n\t\tcase 'IS_POSSIBLE':\r\n\t\t\treturn true\r\n\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\r\n\t\t// \treturn !is_international\r\n\t\tdefault:\r\n\t\t\treturn false\r\n\t}\r\n}\r\n\r\n/**\r\n * @param  {string} text - Input.\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\r\nfunction parse_input(text)\r\n{\r\n\t// Parse RFC 3966 phone number URI.\r\n\tif (text && text.indexOf('tel:') === 0)\r\n\t{\r\n\t\treturn parseRFC3966(text)\r\n\t}\r\n\r\n\tlet number = extract_formatted_phone_number(text)\r\n\r\n\t// If the phone number is not viable, then abort.\r\n\tif (!number || !is_viable_phone_number(number))\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Attempt to parse extension first, since it doesn't require region-specific\r\n\t// data and we want to have the non-normalised number here.\r\n\tconst with_extension_stripped = strip_extension(number)\r\n\tif (with_extension_stripped.ext)\r\n\t{\r\n\t\treturn with_extension_stripped\r\n\t}\r\n\r\n\treturn { number }\r\n}\r\n\r\n/**\r\n * Creates `parse()` result object.\r\n */\r\nfunction result(country, national_number, ext)\r\n{\r\n\tconst result =\r\n\t{\r\n\t\tcountry,\r\n\t\tphone : national_number\r\n\t}\r\n\r\n\tif (ext)\r\n\t{\r\n\t\tresult.ext = ext\r\n\t}\r\n\r\n\treturn result\r\n}\r\n\r\n/**\r\n * Parses a viable phone number.\r\n * Returns `{ country, countryCallingCode, national_number }`.\r\n */\r\nfunction parse_phone_number(formatted_phone_number, default_country, metadata)\r\n{\r\n\tlet { countryCallingCode, number } = extractCountryCallingCode(formatted_phone_number, default_country, metadata)\r\n\r\n\tif (!number) {\r\n\t\treturn { countryCallingCode }\r\n\t}\r\n\r\n\tlet country\r\n\r\n\tif (countryCallingCode)\r\n\t{\r\n\t\tmetadata.chooseCountryByCountryCallingCode(countryCallingCode)\r\n\t}\r\n\telse if (default_country)\r\n\t{\r\n\t\tmetadata.country(default_country)\r\n\t\tcountry = default_country\r\n\t\tcountryCallingCode = getCountryCallingCode(default_country, metadata.metadata)\r\n\t}\r\n\telse return {}\r\n\r\n\tconst { national_number, carrier_code } = parse_national_number(number, metadata)\r\n\r\n\t// Sometimes there are several countries\r\n\t// corresponding to the same country phone code\r\n\t// (e.g. NANPA countries all having `1` country phone code).\r\n\t// Therefore, to reliably determine the exact country,\r\n\t// national (significant) number should have been parsed first.\r\n\t//\r\n\t// When `metadata.json` is generated, all \"ambiguous\" country phone codes\r\n\t// get their countries populated with the full set of\r\n\t// \"phone number type\" regular expressions.\r\n\t//\r\n\tconst exactCountry = find_country_code(countryCallingCode, national_number, metadata)\r\n\tif (exactCountry)\r\n\t{\r\n\t\tcountry = exactCountry\r\n\t\tmetadata.country(country)\r\n\t}\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tnational_number,\r\n\t\tcarrierCode: carrier_code\r\n\t}\r\n}\r\n\r\nfunction parse_national_number(number, metadata)\r\n{\r\n\tlet national_number = parseIncompletePhoneNumber(number)\r\n\tlet carrier_code\r\n\r\n\t// Only strip national prefixes for non-international phone numbers\r\n\t// because national prefixes can't be present in international phone numbers.\r\n\t// Otherwise, while forgiving, it would parse a NANPA number `+1 1877 215 5230`\r\n\t// first to `1877 215 5230` and then, stripping the leading `1`, to `877 215 5230`,\r\n\t// and then it would assume that's a valid number which it isn't.\r\n\t// So no forgiveness for grandmas here.\r\n\t// The issue asking for this fix:\r\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/159\r\n\tconst { number: potential_national_number, carrierCode } = strip_national_prefix_and_carrier_code(national_number, metadata)\r\n\r\n\t// If metadata has \"possible lengths\" then employ the new algorythm.\r\n\tif (metadata.possibleLengths())\r\n\t{\r\n\t\t// We require that the NSN remaining after stripping the national prefix and\r\n\t\t// carrier code be long enough to be a possible length for the region.\r\n\t\t// Otherwise, we don't do the stripping, since the original number could be\r\n\t\t// a valid short number.\r\n\t\tswitch (check_number_length_for_type(potential_national_number, undefined, metadata))\r\n\t\t{\r\n\t\t\tcase 'TOO_SHORT':\r\n\t\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\r\n\t\t\tcase 'INVALID_LENGTH':\r\n\t\t\t\tbreak\r\n\t\t\tdefault:\r\n\t\t\t\tnational_number = potential_national_number\r\n\t\t\t\tcarrier_code = carrierCode\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// If the original number (before stripping national prefix) was viable,\r\n\t\t// and the resultant number is not, then prefer the original phone number.\r\n\t\t// This is because for some countries (e.g. Russia) the same digit could be both\r\n\t\t// a national prefix and a leading digit of a valid national phone number,\r\n\t\t// like `8` is the national prefix for Russia and both\r\n\t\t// `8 800 555 35 35` and `800 555 35 35` are valid numbers.\r\n\t\tif (matches_entirely(national_number, metadata.nationalNumberPattern()) &&\r\n\t\t\t\t!matches_entirely(potential_national_number, metadata.nationalNumberPattern()))\r\n\t\t{\r\n\t\t\t// Keep the number without stripping national prefix.\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tnational_number = potential_national_number\r\n\t\t\tcarrier_code = carrierCode\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tnational_number,\r\n\t\tcarrier_code\r\n\t}\r\n}\r\n\r\n// Determines the country for a given (possibly incomplete) phone number.\r\n// export function get_country_from_phone_number(number, metadata)\r\n// {\r\n// \treturn parse_phone_number(number, null, metadata).country\r\n// }"]}